# Notice the v1beta3 version
apiVersion: scaffolder.backstage.io/v1beta3
kind: Template
# some metadata about the template itself
metadata:
  name: python-app
  title: python flask template
  description: provisions a minimalistic flask application
spec:
  owner: development
  type: service

  # these are the steps which are rendered in the frontend with the form input
  parameters:
    - title: Fill in some steps
      required:
        - component_id
        - environment
      properties:
        component_id:
          title: Component name
          type: string
          description: Provide a component(microservice) name
          pattern: '^([a-zA-Z][a-zA-Z0-9]*)(-[a-zA-Z0-9]+)*$'
        environment:
          title: Environment
          type: string
          description:  The env where this component will be deployed
          enum: 
            - dev
            - prod

  # here's the steps that are executed in series in the scaffolder backend. This takes everything under template folder, and passing the parameters and rendering the actual values. Result of this step would be a file with the actual name and env
  # renders the files we need
  steps:
    - id: fetchBase
      name: Fetch Base
      action: fetch:template
      input:
        url: ./template
        values:
          app_name: ${{ parameters.component_id }}
          app_env: ${{ parameters.environment }}

    
     #creates a new repo and push everything that was within the template file(the rendered files).     
    - id: publish
      name: Publish
      action: publish:github
      input:
        description: This is ${{ parameters.name }}
        repoUrl: github.com?owner=UncleBlazerr-org&repo=${{parameters.component_id}}
        protectDefaultBranch: false
    
    #Once the gitub is repo is created, we're going to register this into Backstage using the catalog register action
    - id: register
      name: Register
      action: catalog:register
      input:
        repoContentsUrl: ${{ steps.publish.output.repoContentsUrl }}
        catalogInfoPath: '/catalog-info.yaml'

  # some outputs which are saved along with the job for use in the frontend
  output:
    links:
      - title: Repository
        url: ${{ steps['publish'].output.remoteUrl }}
      - title: Open in catalog
        icon: catalog
        entityRef: ${{ steps['register'].output.entityRef }}